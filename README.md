#  JVM

## 引言

定义：java程序的运行环境（java二进制字节码的运行环境）

常见的jvm：hotspot

## 内存结构

### 1、程序计数器

作用：记住下一条jvm指令的执行地址

物理上，对应：寄存器

特点：

线程私有，每个线程都有自己的程序计数器

在jvm虚拟机规范里面，唯一不会存在内存溢出的区域

### 2、虚拟机栈

#### 特点

先进后出

线程私有

栈：线程运行时需要的内存空间

一个栈由多个栈帧组成

栈帧：每个方法运行时需要的内存。（参数、局部变量、返回地址）

每个线程只能有一个活动栈帧，对应着当前正在执行的方法

#### 问题辨析：

1、垃圾回收是否涉及栈内存：

> 不涉及。因为栈内存在方法调用结束时就释放了，垃圾回收是回收的堆内存 。

2、栈内存分配越大越好吗：

> 不是。-Xss 栈内存。如果栈内存越大，可运行的线程数就会变少。

3、方法内的局部变量是否线程安全：

>如果方法内的局部变量没有逃离方法的作用访问，就是线程安全的，
>
>如果局部变量引用了对象，并逃离了方法的作用方法，需要考虑线程安全

#### 栈内存溢出

java.lang.StackOverflowError

可以设置栈内存大小：(下面三种写法都代表1M)

> -Xss1m
>
> -Xss1024k
>
> -Xss1048576

栈帧过多导致内存溢出：比如递归调用，没有设置递归终止条件，就会一直调用

栈帧过大导致内存溢出（这种情况一般不容易出现）

#### 线程运行诊断

nohup java xxx &

##### 案例1：cpu占用过多

> 用top定位哪个进程对cpu的占用过高；
>
> 
>
>  ps H -eo pid ,tid,%cpu | grep pid
>
> > 用ps命令进一步定位是哪个线程引起的cpu占用过高，pid-进程，tid-线程
>
> 
>
> jstack pid
>
> > 可以根据线程id[10进制]定位到有问题的线程[16进制]，进一步定位到问题代码的源码行号

##### 案例2：程序运行很长时间没有结果

> jstack pid
>
> > Found one Java-level deadlock:...	死锁了

### 3、本地方法栈

线程私有

java.lang.Object#clone

java.lang.Object#hashCode

java虚拟机调用本地方法时提供的内存空间

为那些用c、c++语言编写的，java去调用（因为java不能直接操作操作系统的底层）

### 4、堆

##### 定义

通过new关键字创建对象都会使用堆内存

线程共享的区域，需要考虑线程安全的问题

有垃圾回收机制

##### 堆内存溢出

java.lang.OutOfMemoryError

设置堆内存：-Xmx8m

##### 堆内存诊断

jps：查看当前系统中有哪些java进程

jmap：查看堆内存占用情况，jmap -heap pid

jconsole：图形界面的，多功能的检测工具，可以连续检测

##### 案例：

垃圾回收后内存占用还是很高

jvisualvm：可视化工具（堆转储：dump）

### 5、方法区

线程共享的区域

##### 方法区内存溢出

jdk1.8：设置元空间大小：-XX:MaxMetaspaceSize=8m

java.lang.OutOfMemoryError: Metaspace



jdk1.6：设置永久代大小：-XX:MaxPermSize=8m

java.lang.OutOfMemoryError: PermGen space

##### 运行时常量池

二进制字节码：类基本信息，常量池，类方法定义，包含了虚拟机指令

```
# 显示编译的详细信息
javap -v 类名.class
```

>常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息
>运行时常量池：常量池是*.clas文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

##### StringTable

>常量池中的字符串仅是符号，第一次用到时才变为对象
>利用串池的机制，来避免重复创建字符串对象
>字符串变量拼接的原理是StringBuilder（1.8）
>字符串常量拼接的原理是编译器优化
>可以使用intern方法，主动将串池中还没有的字符串对象放入串池
>
>>1.8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回
>>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回

